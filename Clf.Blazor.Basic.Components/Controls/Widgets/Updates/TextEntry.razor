@using Convergence
@using Clf.Blazor.Basic.Components.Controls.Models
@using Clf.Blazor.Basic.Components.Controls.Widgets.Containers
@using Clf.Blazor.Basic.Components.Controls.Widgets.Helpers
@using Microsoft.AspNetCore.Components.Web
@using Clf.Blazor.Basic.Components.Controls.Helpers
@using System.ComponentModel
@using System.Runtime.InteropServices
@inherits WidgetBase
@implements IDisposable

@if (IsVisible)
{
  <Alarm BorderStatus="@BorderStatus" ContentDisabledTooltip="@(ShowTooltip? TooltipText:string.Empty)" IsContentDisabled="@IsDisabled">
    @if (IsMultiLine)
    {
      <Tooltip Text="@(ShowTooltip? TooltipText:string.Empty)">
        <textarea class="text-area @Class"
            style="--text-input-width:@GetWidth(); --text-input-height:@GetHeight()"
            disabled="@ShowTooltip"
            @bind="Text" @bind:event="oninput" @onkeydown="@OnEnterKeyDownAsync" />
      </Tooltip>
    }
    else
    {
      <Tooltip Text="@(ShowTooltip? TooltipText:string.Empty)">
        <div class="text-entry @Class" style="--text-input-width:@GetWidth(); --text-input-height:@GetHeight()">
            <input class="text-input" type="text" disabled="@ShowTooltip" show-units="@GetShowUnits()" @bind="Text" @bind:event="oninput" @onkeydown="@OnEnterKeyDownAsync" />
          @if (GetShowUnits())
          {
            <span class="clf-units" disabled="@ShowUnits">@Units</span>
          }
        </div>
      </Tooltip>
    }
  </Alarm>
}

@code
{
    [Parameter]
    public string PVName { get; set; } = string.Empty;
    [Parameter]
    public Type PVDataType { get; set; } = typeof(string);
    [Parameter]
    public int PVElementCount { get; set; } = 1;
    [Parameter]
    public bool IsDisabled { get; set; } = false;
    [Parameter]
    public BorderStatus BorderStatus { get; set; } = BorderStatus.NotConnected;
    [Parameter]
    public string Text { get; set; } = string.Empty;
    [Parameter]
    public string Units { get; set; } = string.Empty;
    [Parameter]
    public bool ShowUnits { get; set; } = false;
    [Parameter]
    public bool IsMultiLine { get; set; } = false;
    [Parameter]
    public int Precision { get; set; } = -1;
    [Parameter]
    public bool IsDisabledOnEnter { get; set; } = false;
    [Parameter]
    public bool WaitForAcknowledgement { get; set; } = false;
    [Parameter]
    public string TooltipText { get; set; } = string.Empty;
    [Parameter]
    public bool ShowTooltip { get; set; } = false;
    [Parameter]
    public string Width { get; set; } = "100";
    [Parameter]
    public string Height { get; set; } = "20";
    [Parameter]
    public string Class { get; set; } = string.Empty;

    private EndPointID? _endPointId;
    private string _previousValue = "";
    private void OnConnectionChanged(Convergence.IO.EPICS.CA.ConnectionEventCallbackArgs args)
    {
        if (args.op == Convergence.IO.EPICS.CA.ConnectionEventCallbackArgs.CA_OP_CONN_UP)
        {
            BorderStatus = BorderStatus.Connected;
            IsDisabled = false;
        }
        else
        {
            BorderStatus = BorderStatus.NotConnected;
            IsDisabled = true;
        }
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();
    }

    protected override async Task OnInitializedAsync()
    {
        // Create an endpoint from Convergence as an EPICS PV using the EndPointName
        _endPointId = new EndPointID(Protocols.EPICS_CA, PVName);
        var epicsSettings = new Convergence.IO.EPICS.CA.Settings(
            datatype: Convergence.IO.EPICS.CA.Helpers.GetDBFieldType(PVDataType),
            elementCount: PVElementCount);
        var endPointArgs = new EndPointBase<Convergence.IO.EPICS.CA.Settings> { EndPointID = _endPointId, Settings = epicsSettings };
        var connResult = await Convergence.IO.EPICS.CA.ConvergeOnEPICSChannelAccess.Hub.ConnectAsync(endPointArgs, (Convergence.IO.EPICS.CA.EventCallbackDelegate.ConnectCallback)OnConnectionChanged);
    }

    private bool GetShowUnits()
    {
        return (!string.IsNullOrEmpty(Units) && ShowUnits);
    }

    private string GetWidth()
    {
        return Width != null ? $"{Width}px" : "var(--clf-text-entry-default-width)";
    }

    private string GetHeight()
    {
        return Height != null ? $"{Height}px" : "var(--clf-text-entry-default-height)";
    }


    void IDisposable.Dispose()
    {
        if (_endPointId != null)
            // Disconnect to the EndPoint
            Convergence.IO.EPICS.CA.ConvergeOnEPICSChannelAccess.Hub.Disconnect(_endPointId);
    }

    public async Task OnEnterKeyDownAsync(KeyboardEventArgs e)
    {
        //only try to write to the PV if Connected and "Enter" key is pressed
        if (BorderStatus == BorderStatus.Connected && (e.Code == "Enter" || e.Code == "NumpadEnter"))
        {
            // Get ValueToWrite from Text and try convert into the chosen System.Type
            object valueToWrite = Convert.ChangeType(Text, PVDataType);
            nint valuePtr = GCHandle.Alloc(valueToWrite, GCHandleType.Pinned).AddrOfPinnedObject();
            // Write async and await a callback if successful
            EndPointStatus status = await Convergence.IO.EPICS.CA.ConvergeOnEPICSChannelAccess.Hub.WriteAsync<Convergence.IO.EPICS.CA.EventCallbackDelegate.WriteCallback>(_endPointId, valuePtr, (_) =>
            {
                // Check if the value was written successfully by doing a ReadAsync
                Convergence.IO.EPICS.CA.ConvergeOnEPICSChannelAccess.Hub.ReadAsync<Convergence.IO.EPICS.CA.EventCallbackDelegate.ReadCallback>(_endPointId, (rbv) =>
				{
                    object data = Convergence.IO.EPICS.CA.Helpers.DecodeEventData(rbv);
                    if (data.ToString() == Text)
                        _previousValue = Text;
                        else
                        Text = _previousValue;
				});
            });
        }
    }
}